00000 00 1 0 0 0 0 1 0 0 01 1 0000 0000 0100 00000000 init:       pc = 0  seti
10111 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00000011 fetch:      ji fetch_normal ! ignore les interruption matérielle si seti
10001 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 01010111             jq irq_mat ! gère une interruption matérielle
00000 00 1 0 0 0 1 0 0 0 00 1 0000 0000 0100 00000000 fetch_normal: pc = 0 + pc ema
00000 00 0 0 1 0 0 0 0 0 01 0 0000 0000 0000 00000000             read
00000 00 1 0 1 0 0 0 0 0 00 1 0000 0101 0000 00000000             read  pc = pc +1
00000 00 0 0 0 0 0 0 0 0 01 1 0010 0000 0000 00000000             ir = mb
00000 00 1 0 0 0 1 0 0 0 00 1 0000 0000 0100 00000000             pc = 0 +pc ema
00000 00 0 0 1 0 0 0 0 0 01 0 0000 0000 0000 00000000             read
00000 00 1 0 1 0 0 0 0 0 00 1 0000 0101 0000 00000000             read  pc = pc +1
00000 00 0 0 0 0 0 0 0 0 01 1 1110 0000 0000 00000000             mk2 = mb
11111 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00110011             j7   branch_autres      ! 1x : branchement ou autres instr
11100 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00001111             j4 oooo_imm
00000 00 1 1 0 0 0 0 0 0 01 0 0000 0000 0000 00000001 oooo_reg:   mb = labus
10000 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00010011             jp  oooo_lu
00000 10 1 0 0 0 0 0 0 0 01 1 1101 0000 1110 00000000 oooo_imm:   mk1 = shr(mk2)
00000 10 1 0 0 0 0 0 0 0 01 1 1101 0000 1101 00000000             mk1 = shr(mk1)
00000 10 1 0 0 0 0 0 0 0 01 1 1101 0000 1101 00000000             mk1 = shr(mk1)
00000 10 1 1 0 0 0 0 0 0 01 0 0000 0000 1101 00000000             mb  = shr(mk1)
11110 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00100010 oooo_lu:    j6   memoire            ! 01 : load ou store
00000 00 1 0 0 0 0 0 0 0 01 1 1101 0000 1110 00000000 calcul:     mk1 = mk2
11011 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00010111 testbar:    j3  testplusun
00000 00 0 1 0 0 0 0 0 0 11 0 0000 0110 0000 00000000             mb = mb xor ff
11010 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00011001 testplusun: j2 calculer
00000 00 0 1 0 0 0 0 0 0 00 0 0000 0101 0000 00000000             mb = mb + 1
00000 00 1 0 0 0 0 0 0 0 01 1 1110 0000 0010 00000000 calculer:   mk2 = ir
11101 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00011101             j5  avecs
00000 00 0 1 0 0 0 0 0 0 01 0 0000 0000 0000 00001010 sanss:      mb = mb lual lbbus
10000 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00011110             jp ranger
00000 00 0 1 0 0 0 0 0 1 01 0 0000 0000 0000 00001010 avecs:      mb = mb lual lbbus majflag
00000 01 1 0 0 0 0 0 0 0 00 1 1101 1101 1101 00000000 ranger:     mk1 = shl (mk1 + mk1)
00000 01 1 0 0 0 0 0 0 0 00 1 1101 1101 1101 00000000             mk1 = shl (mk1 + mk1)
00000 00 0 0 0 0 0 0 0 0 01 1 0000 0000 0000 00000100             lcbus = mb
10000 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00000001             jp fetch
00000 00 1 0 0 0 0 0 0 0 01 1 1101 0000 1110 00000000 memoire:    mk1 = mk2
00000 00 0 0 0 0 0 0 0 0 00 1 1101 0000 0000 00000010             mk1 = mb + lbbus ! dans mk1 se trouve depl(mb) + base(lbbus)
00000 00 1 0 0 0 1 0 0 0 00 1 0100 1101 0100 00000000             0 = 0 + mk1 ema ! Chargement de mk1 dans ma
11101 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00101101             j5 store
00000 00 0 0 1 0 0 0 0 0 01 0 0000 0000 0000 00000000 load:       read
00000 00 0 0 1 0 0 0 0 0 01 0 0000 0000 0000 00000000             read
00000 00 1 0 0 0 0 0 0 0 01 1 1101 0000 0010 00000000             mk1 = ir
00000 01 1 0 0 0 0 0 0 0 00 1 1101 1101 1101 00000000             mk1 = shl (mk1 + mk1)
00000 01 1 0 0 0 0 0 0 0 00 1 1101 1101 1101 00000000             mk1 = shl (mk1 + mk1)
00000 00 0 0 0 0 0 0 0 0 01 1 0000 0000 0000 00000100             lcbus = mb
10000 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00000001             jp fetch ! Il y a répétition de code (ranger) mais on gagne 1 micro-instruction
00000 00 1 0 0 0 0 0 0 0 01 1 1101 0000 0010 00000000 store:      mk1 = ir
00000 00 1 1 0 0 0 0 0 0 00 1 0100 0000 0100 00000010             0 = 0 + lbbus emb
00000 00 0 0 0 1 0 0 0 0 01 0 0000 0000 0000 00000000             write
00000 00 0 0 0 1 0 0 0 0 01 0 0000 0000 0000 00000000             write
00000 00 0 0 0 1 0 0 0 0 01 0 0000 0000 0000 00000000             write
10000 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00000001             jp fetch
11110 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 01000011 branch_autres:  j6  autres
00000 00 1 1 0 0 0 0 0 0 00 0 0000 1110 0000 00000000                 mb = pc + mk2
00000 00 1 0 0 0 0 0 0 0 01 1 1101 0000 0000 00000000                 mk1 = pc
11011 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00111100                 j3   beq
11010 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00111001                 j2   bcs
10000 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00111111                 jp   brancher        ! bal : inconditionnel !
00000 10 1 0 0 0 0 0 0 0 01 1 1110 0000 1100 00000000 bcs:            mk2 = shr (f)
00000 10 1 0 0 0 0 0 0 0 01 1 1110 0000 1110 00000000                 mk2 = shr (mk2)
10000 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00111101                 jp test_flag
00000 00 1 0 0 0 0 0 0 0 01 1 1110 0000 1100 00000000 beq:            mk2 = f
00000 00 1 0 0 0 0 0 0 0 10 1 1110 0101 1110 00000000 test_flag:      mk2 = mk2 and 1
10110 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00000001                 jz   fetch
00000 00 0 0 0 0 0 0 0 0 01 1 0000 0000 0000 00000000 brancher:       pc = mb
11101 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00000001                 j5    fetch           ! pas bl : terminé     !
00000 00 1 0 0 0 0 0 0 0 01 1 0011 0000 1101 00000000                 tir = mk1            ! bl : sauver --> lr/tir !
10000 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00000001                 jp   fetch
11101 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 01000110 autres:         j5  instr_it
00000 00 1 1 0 0 0 0 0 0 01 0 0000 0000 0000 00000001                 mb = labus
10000 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00010100                 jp calcul
11100 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 01001100 instr_it:       j4 it_log
11011 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 01001010                 j3 clear
00000 00 0 0 0 0 0 1 0 0 01 0 0000 0000 0000 00000000 set:            seti
10000 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00000001                 jp fetch
00000 00 0 0 0 0 0 0 1 0 01 0 0000 0000 0000 00000000 clear:          clri
10000 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00000001                 jp fetch
11011 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 01010001 it_log:  j3 swi
00000 00 1 0 0 0 0 0 0 0 01 1 1100 0000 1111 00000000 rti:            f = ac ! Restoration de cpsr depuis spsr
00000 00 1 0 0 0 0 0 0 0 01 1 0000 0000 0111 00000000                 pc = a ! Restoration de pc depuis slr
00000 00 0 0 0 0 0 0 1 0 01 0 0000 0000 0000 00000000                 clri ! autorise à nouveau les interruptions
10000 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00000001                 jp fetch
10111 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00000001 swi:            ji fetch ! Si une interruption est déja en cours, on saute
00000 00 1 0 0 0 0 0 0 0 01 1 0111 0000 0000 00000000                 a = pc ! Sauvegarde de pc dans slr
00000 00 1 0 0 0 0 0 0 0 01 1 1111 0000 1100 00000000                 ac = f ! Sauvegarde de cpsr dans spsr
00000 00 0 0 0 0 0 1 0 0 01 0 0000 0000 0000 00000000                 seti ! Bloque la gestion des interruptions
00000 01 1 0 0 0 0 0 0 0 00 1 0000 0101 0101 00000000                 pc = shl(1 + 1) ! Mise en place du vecteur swi dans pc (Ox4)
10000 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00000001                 jp fetch
00000 00 1 0 0 0 0 0 0 0 01 1 0111 0000 0000 00000000 irq_mat:        a = pc ! Sauvegarde de pc dans slr
00000 00 1 0 0 0 0 0 0 0 01 1 1111 0000 1100 00000000                 ac = f ! Sauvegarde de cpsr dans spsr
00000 00 0 0 0 0 0 1 0 0 01 0 0000 0000 0000 00000000                 seti ! Bloque la gestion des interruptions
00000 00 1 0 0 0 0 0 0 0 00 1 0000 0101 0101 00000000                 pc = 1 + 1 ! Mise en place du vecteur interruption matérielle dans pc (Ox2)
10000 00 0 0 0 0 0 0 0 0 01 0 0000 0000 0000 00000001                 jp fetch
